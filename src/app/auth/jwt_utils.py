from datetime import datetime, timedelta, timezone
from typing import Dict, Any, Optional, TYPE_CHECKING
from pathlib import Path
import jwt
import uuid
from config import settings

if TYPE_CHECKING:
    from app.auth.models import User


class JWTUtils:
    """Utilities for JWT token operations"""
    
    def __init__(self):
        self.algorithm = settings.jwt_algorithm
        self.access_token_expire_minutes = settings.jwt_access_token_expire_minutes
        self.refresh_token_expire_days = settings.jwt_refresh_token_expire_days
        
        # Load RSA keys for RS256
        if self.algorithm == "RS256":
            private_key_path = Path(settings.jwt_private_key_path)
            public_key_path = Path(settings.jwt_public_key_path)
            
            if not private_key_path.exists():
                raise FileNotFoundError(f"Private key not found at {private_key_path}")
            if not public_key_path.exists():
                raise FileNotFoundError(f"Public key not found at {public_key_path}")
            
            with open(private_key_path, "r") as f:
                self.private_key = f.read()
            
            with open(public_key_path, "r") as f:
                self.public_key = f.read()
        else:
            # Fallback to HS256 for backward compatibility
            self.secret_key = settings.jwt_secret_key
            self.private_key = None
            self.public_key = None
    
    def create_access_token(self, user: "User") -> str:
        """Create JWT access token"""
        payload = {
            "user_id": user.id,
            "email": user.email,
            "is_seller": user.is_seller,
            "type": "access",
            "exp": datetime.now(timezone.utc) + timedelta(minutes=self.access_token_expire_minutes)
        }
        if self.algorithm == "RS256":
            return jwt.encode(payload, self.private_key, algorithm=self.algorithm)
        else:
            return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def create_refresh_token_string(self) -> str:
        """Create refresh token as UUID string (will be generated by DB)"""
        return str(uuid.uuid4())  # Fallback if needed
    
    def verify_access_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Verify and decode JWT access token"""
        try:
            if self.algorithm == "RS256":
                payload = jwt.decode(token, self.public_key, algorithms=[self.algorithm])
            else:
                payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            if payload.get("type") != "access":
                return None
            return payload
        except jwt.PyJWTError:
            return None
    
    def get_user_id_from_token(self, token: str) -> Optional[int]:
        """Extract user ID from access token"""
        payload = self.verify_access_token(token)
        return payload.get("user_id") if payload else None
    
    def create_order_token(self, order_id: int, expire_minutes: int = 525600) -> str:
        """
        Create JWT token for order information.
        
        Args:
            order_id: Order ID to include in token
            expire_minutes: Token expiration time in minutes (default: 1 year)
        
        Returns:
            JWT token string
        """
        payload = {
            "order_id": order_id,
            "type": "order",
            "exp": datetime.now(timezone.utc) + timedelta(minutes=expire_minutes)
        }
        if self.algorithm == "RS256":
            return jwt.encode(payload, self.private_key, algorithm=self.algorithm)
        else:
            return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_order_token(self, token: str) -> Optional[Dict[str, Any]]:
        """
        Verify and decode JWT order token.
        
        Args:
            token: JWT token string
        
        Returns:
            Decoded payload if valid, None otherwise
        """
        try:
            if self.algorithm == "RS256":
                payload = jwt.decode(token, self.public_key, algorithms=[self.algorithm])
            else:
                payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            if payload.get("type") != "order":
                return None
            return payload
        except jwt.PyJWTError:
            return None
    
    def get_public_key(self) -> str:
        """
        Get public key for JWT verification.
        
        Returns:
            Public key as string
        """
        if self.algorithm == "RS256":
            return self.public_key
        else:
            raise ValueError("Public key is only available for RS256 algorithm")
    
    def get_order_id_from_token(self, token: str) -> Optional[int]:
        """
        Extract order ID from order token.
        
        Args:
            token: JWT token string
        
        Returns:
            Order ID if token is valid, None otherwise
        """
        payload = self.verify_order_token(token)
        return payload.get("order_id") if payload else None