from typing import Optional
from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import HTTPException, status
from app.auth.service import AuthService
from app.auth.jwt_utils import JWTUtils
from app.auth.models import User
from app.auth import schemas
from utils.errors_handler import handle_alchemy_error

# Common exceptions
INVALID_CREDENTIALS = HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Invalid email or password"
)

INVALID_REFRESH_TOKEN = HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Invalid or expired refresh token"
)


class AuthManager:
    """Manager for authentication business logic"""
    
    def __init__(self):
        self.service = AuthService()
        self.jwt_utils = JWTUtils()

    async def _create_tokens_for_user(self, session: AsyncSession, user: User) -> schemas.TokenResponse:
        """Create access and refresh tokens for user"""
        # Create access token (JWT)
        access_token = self.jwt_utils.create_access_token(user)
        
        # Create refresh token in database (UUID generated by DB)
        expires_at = datetime.now() + timedelta(days=self.jwt_utils.refresh_token_expire_days)
        refresh_token_record = await self.service.create_refresh_token(session, user.id, expires_at)
        
        return schemas.TokenResponse(
            access_token=access_token,
            refresh_token=str(refresh_token_record.token)
        )
    @handle_alchemy_error
    async def register_user(self, session: AsyncSession, user_data: schemas.UserRegistration) -> schemas.TokenResponse:
        """Register a new user"""
        # Hash password
        password_hash = self.service.password_utils.hash_password(user_data.password)
        
        # Create user
        user = await self.service.create_user(session, user_data.email, password_hash)
        
        # Create tokens
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def login_user(self, session: AsyncSession, login_data: schemas.UserLogin) -> schemas.TokenResponse:
        """Login user"""
        # Find user by email
        user = await self.service.get_user_by_email(session, login_data.email)
        if not user:
            raise INVALID_CREDENTIALS
        
        # Verify password
        if not await self.service.verify_user_password(login_data.password, user.password_hash):
            raise INVALID_CREDENTIALS
        
        # Create tokens
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def refresh_tokens(self, session: AsyncSession, refresh_data: schemas.RefreshTokenRequest) -> schemas.TokenResponse:
        """Refresh access token"""
        # Check if refresh token exists in database and is not revoked
        db_token = await self.service.get_refresh_token(session, refresh_data.refresh_token)
        if not db_token or db_token.is_revoked or db_token.expires_at < datetime.now():
            raise INVALID_REFRESH_TOKEN
        
        # Get user
        user = await self.service.get_user(session, db_token.user_id)
        if not user:
            raise INVALID_REFRESH_TOKEN
        
        # Revoke old refresh token
        await self.service.revoke_refresh_token(session, refresh_data.refresh_token)
        
        # Create new tokens
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def get_user(self, session: AsyncSession, user_id: int) -> dict:
        """Get current user by ID"""
        user = await self.service.get_user(session, user_id)
        if not user:
            return None
        
        return {
            "id": user.id,
            "email": user.email,
            "is_seller": user.is_seller
        }
    
    @handle_alchemy_error
    async def get_current_user_by_token(self, session: AsyncSession, token: str) -> User:
        """Get current user by token"""
        # Verify token and get user_id
        payload = self.jwt_utils.verify_access_token(token)
        if not payload:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
        
        user_id = payload["user_id"]
        
        # Get user from database
        user = await self.service.get_user(session, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )
        
        return user
