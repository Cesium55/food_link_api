from typing import Optional
from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import HTTPException, status
from app.auth.service import AuthService
from app.auth.jwt_utils import JWTUtils
from app.auth.models import User
from app.auth import schemas
from app.sellers.service import SellersService
from utils.errors_handler import handle_alchemy_error
from utils.redis.verification_codes import store_verification_code, verify_code, _format_phone_number
from config import settings
from logger import get_sync_logger
from utils.tg_gateway_manager import TelegramGatewayClient

logger = get_sync_logger(__name__)

# Common exceptions
INVALID_CREDENTIALS = HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Invalid email or password"
)

INVALID_REFRESH_TOKEN = HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Invalid or expired refresh token"
)

EMAIL_AUTH_DISABLED = HTTPException(
    status_code=status.HTTP_403_FORBIDDEN,
    detail="Email authentication is disabled"
)

PHONE_AUTH_DISABLED = HTTPException(
    status_code=status.HTTP_403_FORBIDDEN,
    detail="Phone authentication is disabled"
)


class AuthManager:
    """Manager for authentication business logic"""
    
    def __init__(self):
        self.service = AuthService()
        self.jwt_utils = JWTUtils()
        self.sellers_service = SellersService()
        self.code_manager = TelegramGatewayClient

    async def _create_tokens_for_user(self, session: AsyncSession, user: User) -> schemas.TokenResponse:
        """Create access and refresh tokens for user"""
        # Create access token (JWT)
        access_token = self.jwt_utils.create_access_token(user)
        
        # Create refresh token in database (UUID generated by DB)
        expires_at = datetime.now() + timedelta(days=self.jwt_utils.refresh_token_expire_days)
        refresh_token_record = await self.service.create_refresh_token(session, user.id, expires_at)
        
        return schemas.TokenResponse(
            access_token=access_token,
            refresh_token=str(refresh_token_record.token)
        )
    def _format_phone_number(self, phone: str) -> str:
        """Format phone number to standard format"""
        return _format_phone_number(phone)

    async def _generate_phone_verification_code(self, phone: str) -> str:
        """Generate/send phone verification code depending on app settings."""
        if settings.debug and settings.mock_phone_verification_code:
            return "123456"

        async with self.code_manager() as sms_manager:
            return await sms_manager.send_verification_code(phone)
    
    @handle_alchemy_error
    async def register_user(self, session: AsyncSession, user_data: schemas.UserRegistration) -> schemas.TokenResponse:
        """Register a new user"""
        # Check if email/phone auth is enabled
        if user_data.email and not settings.auth_enable_email:
            raise EMAIL_AUTH_DISABLED
        if user_data.phone and not settings.auth_enable_phone:
            raise PHONE_AUTH_DISABLED
        
        # Hash password
        password_hash = self.service.password_utils.hash_password(user_data.password)
        
        # Format phone if provided
        phone = None
        if user_data.phone:
            phone = self._format_phone_number(user_data.phone)
            # Check if phone already exists
            existing_user = await self.service.get_user_by_phone(session, phone)
            if existing_user:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="User with this phone number already exists"
                )
        
        # Check if email already exists
        if user_data.email:
            existing_user = await self.service.get_user_by_email(session, user_data.email)
            if existing_user:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="User with this email already exists"
                )
        
        # Create user
        user = await self.service.create_user(
            session, 
            email=user_data.email,
            phone=phone,
            password_hash=password_hash
        )
        
        # If registration by phone, send verification code immediately
        if phone:
            try:
                code = await self._generate_phone_verification_code(phone)
                
                # Store code in Redis
                await store_verification_code(phone, code, expire_seconds=300)
                
                logger.info(
                    "Phone verification code sent during registration",
                    extra={
                        "phone": phone,
                        "code": code,
                        "user_id": user.id
                    }
                )
            except Exception as e:
                # Log error but don't fail registration
                logger.error(
                    f"Failed to send verification code during registration: {str(e)}",
                    extra={"phone": phone, "user_id": user.id}
                )
        
        # Create tokens
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def login_user(self, session: AsyncSession, login_data: schemas.UserLogin) -> schemas.TokenResponse:
        """Login user"""
        # Check if email/phone auth is enabled
        if login_data.email and not settings.auth_enable_email:
            raise EMAIL_AUTH_DISABLED
        if login_data.phone and not settings.auth_enable_phone:
            raise PHONE_AUTH_DISABLED
        
        # Find user by email or phone
        user = None
        if login_data.email:
            user = await self.service.get_user_by_email(session, login_data.email)
        elif login_data.phone:
            formatted_phone = self._format_phone_number(login_data.phone)
            user = await self.service.get_user_by_phone(session, formatted_phone)
        
        if not user:
            raise INVALID_CREDENTIALS
        
        # Verify password
        if not await self.service.verify_user_password(login_data.password, user.password_hash):
            raise INVALID_CREDENTIALS
        
        # Create tokens
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def refresh_tokens(self, session: AsyncSession, refresh_data: schemas.RefreshTokenRequest) -> schemas.TokenResponse:
        """Refresh access token"""
        # Check if refresh token exists in database and is not revoked
        db_token = await self.service.get_refresh_token(session, refresh_data.refresh_token)
        if not db_token or db_token.is_revoked or db_token.expires_at < datetime.now():
            raise INVALID_REFRESH_TOKEN
        
        # Get user
        user = await self.service.get_user(session, db_token.user_id)
        if not user:
            raise INVALID_REFRESH_TOKEN
        
        # Revoke old refresh token
        await self.service.revoke_refresh_token(session, refresh_data.refresh_token)
        
        # Create new tokens
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def get_user(self, session: AsyncSession, user_id: int) -> dict:
        """Get current user by ID"""
        user = await self.service.get_user(session, user_id)
        if not user:
            return None
        
        return {
            "id": user.id,
            "email": user.email,
            "phone": user.phone,
            "phone_verified": user.phone_verified,
            "is_seller": user.is_seller
        }
    
    @handle_alchemy_error
    async def resend_phone_verification_code(self, session: AsyncSession, user_id: int) -> dict:
        """Resend verification code to phone number (for existing users)"""
        if not settings.auth_enable_phone:
            raise PHONE_AUTH_DISABLED
        
        # Get user
        user = await self.service.get_user(session, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        # Check if user has phone
        if not user.phone:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User does not have a phone number"
            )
        
        formatted_phone = user.phone
        
        # Generate and send code
        code = await self._generate_phone_verification_code(formatted_phone)
        
        # Store code in Redis
        await store_verification_code(formatted_phone, code, expire_seconds=300)
        
        logger.info(
            "Phone verification code resent",
            extra={
                "phone": formatted_phone,
                "code": code,
                "user_id": user.id
            }
        )
        
        return {
            "message": "Verification code sent successfully",
            "phone": formatted_phone
        }
    
    @handle_alchemy_error
    async def verify_phone_code(self, session: AsyncSession, code: str, user_id: int) -> schemas.TokenResponse:
        """Verify phone code and update user phone_verified status"""
        if not settings.auth_enable_phone:
            raise PHONE_AUTH_DISABLED
        
        # Get user
        user = await self.service.get_user(session, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        print(user)
        
        # Check if user has phone
        if not user.phone:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User does not have a phone number"
            )
        
        formatted_phone = user.phone
        
        # Verify code
        is_valid = await verify_code(formatted_phone, code)
        if not is_valid:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid or expired verification code"
            )
        
        # Update phone_verified status
        user = await self.service.update_user_phone_verified(session, user_id, True)
        
        # Create new tokens with updated phone_verified status
        tokens = await self._create_tokens_for_user(session, user)
        
        await session.commit()
        return tokens
    
    @handle_alchemy_error
    async def get_current_user_by_token(self, session: AsyncSession, token: str) -> User:
        """Get current user by token"""
        # Verify token and get user_id
        payload = self.jwt_utils.verify_access_token(token)
        if not payload:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
        
        user_id = payload["user_id"]
        
        # Get user from database
        user = await self.service.get_user(session, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )
        
        return user
    
    @handle_alchemy_error
    async def register_firebase_token(self, session: AsyncSession, user_id: int, firebase_token: str) -> dict:
        """Register or update Firebase token for user and seller if user is seller"""
        # Update user's firebase token
        user = await self.service.update_user_firebase_token(session, user_id, firebase_token)
        
        # If user is seller, also update seller's firebase token
        if user.is_seller:
            seller = await self.sellers_service.get_seller_by_master_id(session, user_id)
            if seller:
                await self.sellers_service.update_seller_firebase_token(
                    session, seller.id, firebase_token
                )

        
        await session.commit()
        
        
        return {
            "message": "Firebase token registered successfully",
            "user_id": user_id
        }

    @handle_alchemy_error
    async def bind_email(
        self, session: AsyncSession, user_id: int, email: str
    ) -> dict:
        """Bind email for current user without verification."""
        user = await self.service.get_user(session, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found",
            )

        if user.email:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User already has an email",
            )

        existing_user = await self.service.get_user_by_email(session, email)
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User with this email already exists",
            )

        await self.service.update_user_email(session, user_id, email)
        await session.commit()
        return {
            "message": "Email bound successfully",
            "user_id": user_id,
            "email": email,
        }

    @handle_alchemy_error
    async def update_user_last_location(
        self, session: AsyncSession, user_id: int, latitude: float, longitude: float
    ) -> dict:
        """Update user's last known location"""
        user = await self.service.update_user_last_location(session, user_id, latitude, longitude)
        await session.commit()
        
        logger.info(
            "User last location updated",
            extra={
                "user_id": user_id,
                "latitude": latitude,
                "longitude": longitude
            }
        )
        
        return {
            "message": "Last location updated successfully",
            "user_id": user_id,
            "latitude": latitude,
            "longitude": longitude
        }
